{-
    @SoftwareMaestro: trial smart contract and its implementation.

    Task: Develop a smart contract that handles TON transactions with the following features:

    1. Accept Funds (`op::accept_funds`): The contract should accept TON payments from users. If a user sends less than 2 TON, the contract should return the funds to the sender. If 2 TON or more are sent, the funds should be saved on the contract's balance.

    2. Admin Withdraw (`op::admin_withdraw`): The contract's owner should be able to withdraw TON from the contract. However, the contract should always maintain a minimum balance of 0.5 TON. The admin can only withdraw funds exceeding this minimum.

    3. Lock Contract (`op::lock`): The contract owner can lock the contract, preventing any further fund deposits.

    4. Unlock Contract (`op::unlock`): The contract owner can unlock the contract to resume normal operations.
-}

#include "imports/stdlib.fc";
#include "imports/op.fc";

const int min_tons_for_storage = 500000000;

global slice storage::owner_address;
global int storage::is_locked?;

() load_data() impure inline {
    var ds = get_data().begin_parse();
    storage::owner_address = ds~load_msg_addr();
    storage::is_locked? = ds~load_uint(1);
    ds.end_parse();
}

() save_data() impure inline {
    set_data(
        begin_cell()
            .store_slice(storage::owner_address)
            .store_uint(storage::is_locked?, 1)
        .end_cell()
    );
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        return ();
    }

    slice sender = cs~load_msg_addr();
    int op = in_msg_body~load_uint(32);

    load_data();

    if (op == op::accept_funds) {
        if (storage::is_locked? == 1) {
            var msg = begin_cell()
                      .store_uint(0x10, 6)
                      .store_slice(sender) 
                      .store_coins(msg_value)
                      .store_uint(0, 107)
                    .end_cell();
            send_raw_message(msg, 64);
            throw(100);
        }

        if (msg_value < 2000000000) {
            var msg = begin_cell()
                      .store_uint(0x10, 6)
                      .store_slice(sender) 
                      .store_coins(msg_value)
                      .store_uint(0, 107)
                    .end_cell();
            send_raw_message(msg, 64);
            throw(101);
        }

        return();
    }

    if (op == op::admin_withdraw) {
        throw_unless(401, equal_slices(sender, storage::owner_address));
        raw_reserve(min_tons_for_storage, 0);
        var msg = begin_cell()
                    .store_uint(0x10, 6) 
                    .store_slice(storage::owner_address)
                    .store_coins(0)
                    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                  .end_cell();
        send_raw_message(msg, 128);
        
        return();
    }

    if (op == op::lock) {
        throw_unless(401, equal_slices(sender, storage::owner_address));
        storage::is_locked? = 1;
        save_data();

        return();
    }

    if (op == op::unlock) {
        throw_unless(401, equal_slices(sender, storage::owner_address));
        storage::is_locked? = 0;
        save_data();

        return();
    }

    throw(0xfffff);
}

;; Get Methods

(slice) get_owner() method_id {
    load_data();
    return storage::owner_address;
}

(int) get_is_locked() method_id {
    load_data();
    return storage::is_locked?;
}
